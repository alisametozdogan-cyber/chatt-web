<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Pico Park Mini - Oda ile</title>
  <style>
    body { margin:0; background:#111; font-family:Arial; color:#eee; }
    #game-container { position:relative; margin:20px auto; display:none; }
    #ui { position:absolute; top:10px; left:10px; background:rgba(0,0,0,0.5); padding:10px; border-radius:8px; }
    #join { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); background:#222; padding:30px; border-radius:12px; text-align:center; width:350px; }
    #share-link { margin:15px 0; padding:10px; background:#333; word-break:break-all; }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
  <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
</head>
<body>

<div id="join">
  <h2>Pico Park Mini - Oda Sistemi</h2>
  <p>Oda ID'si otomatik oluşuyor veya linktekiyle aynı odaya giriyorsun.</p>
  <div id="share-link">Oda linki yükleniyor...</div>
  <button onclick="startGame()" style="padding:12px 30px; font-size:18px;">Oyuna Gir</button>
</div>

<div id="game-container"></div>

<div id="ui">Oyuncular: <span id="playerCount">1</span> | Oda: <span id="roomDisplay"></span></div>

<script>
// ============== ODA SİSTEMİ ==============
const urlParams = new URLSearchParams(window.location.search);
let roomId = urlParams.get('room');

if (!roomId) {
  // Yeni oda oluştur (random 8 karakter)
  roomId = Math.random().toString(36).substring(2, 10);
  history.replaceState(null, '', `?room=${roomId}`);
}

document.getElementById('share-link').innerText = 
  `Arkadaşlarına bu linki at:\n${window.location.origin}${window.location.pathname}?room=${roomId}`;

document.getElementById('roomDisplay').innerText = roomId;

// ============== OYUN DEĞİŞKENLERİ ==============
let peer;
let connections = [];
let localPlayer;
let players = {};
let myId;
let game;

const config = {
  type: Phaser.AUTO,
  width: 960,
  height: 540,
  parent: 'game-container',
  physics: {
    default: 'arcade',
    arcade: { gravity: { y: 800 }, debug: false }
  },
  scene: { preload, create, update }
};

let music, jumpSound;

// ============== BAŞLAT ==============
function startGame() {
  document.getElementById('join').style.display = 'none';
  document.getElementById('game-container').style.display = 'block';

  peer = new Peer(); // otomatik ID

  peer.on('open', (id) => {
    myId = id;
    console.log("Benim Peer ID:", id, "Oda:", roomId);
    joinRoom();
  });

  peer.on('connection', (conn) => {
    if (conn.metadata !== roomId) return; // sadece aynı oda
    handleConnection(conn);
  });

  game = new Phaser.Game(config);
}

function joinRoom() {
  // Her 2 saniyede bir "ben buradayım" sinyali gönder (broadcast için basit hack)
  setInterval(() => {
    if (!myId) return;
    // Mevcut bağlantılara bildir
    connections.forEach(c => {
      if (c.open) c.send({ type: 'heartbeat', from: myId, room: roomId });
    });

    // Yeni bağlantı kurmak için... (basitçe herkese connect dene - production'da list lazım)
    // Şimdilik manuel biliniyor varsayalım, yoksa basitçe host herkese connect dener
  }, 2000);
}

// Bağlantı yönetimi
function handleConnection(conn) {
  if (connections.some(c => c.peer === conn.peer)) return;

  conn.on('open', () => {
    connections.push(conn);
    console.log("Bağlandı:", conn.peer);
    updatePlayerCount();

    // Yeni oyuncuya kendini tanıt
    conn.send({ type: 'join', id: myId, room: roomId });

    // Mevcut oyuncuları gönder
    conn.send({
      type: 'players',
      players: Object.keys(players).filter(p => p !== myId)
    });
  });

  conn.on('data', (data) => {
    if (data.room !== roomId) return;

    if (data.type === 'move') {
      if (!players[data.from]) createRemotePlayer(data.from, data.x, data.y);
      const p = players[data.from];
      p.x = data.x;
      p.y = data.y;
      p.sprite.x = data.x;
      p.sprite.y = data.y;
    }
    else if (data.type === 'join') {
      if (data.id !== myId && !players[data.id]) {
        createRemotePlayer(data.id);
      }
    }
    else if (data.type === 'players') {
      data.players.forEach(pid => {
        if (pid !== myId && !players[pid]) {
          // Yeni peer'e connect dene
          const newConn = peer.connect(pid, { metadata: roomId });
          handleConnection(newConn);
        }
      });
    }
  });

  conn.on('close', () => {
    connections = connections.filter(c => c.peer !== conn.peer);
    if (players[conn.peer]) {
      players[conn.peer].sprite.destroy();
      delete players[conn.peer];
    }
    updatePlayerCount();
  });
}

function updatePlayerCount() {
  document.getElementById('playerCount').innerText = connections.length + 1;
}

// ============== PHASER ==============
function preload() {
  this.load.image('player', 'https://labs.phaser.io/assets/sprites/phaser-dude.png');
  this.load.audio('bgm', 'https://cdn.pixabay.com/audio/2022/03/15/audio_6d4f8e6e8e.mp3');
  this.load.audio('jump', 'https://labs.phaser.io/assets/audio/jump.ogg');
}

function create() {
  this.cameras.main.setBackgroundColor('#334455');
  music = this.sound.add('bgm', { loop: true, volume: 0.4 });
  jumpSound = this.sound.add('jump', { volume: 0.7 });
  music.play();

  const platforms = this.physics.add.staticGroup();
  platforms.create(480, 520, null).setSize(960, 40).refreshBody().setVisible(false);

  const colors = [0xffffff, 0xff5555, 0x55ff55, 0x5555ff, 0xffff55];
  const myColor = colors[Math.floor(Math.random() * colors.length)];

  localPlayer = this.physics.add.sprite(100 + Math.random()*200, 100, 'player');
  localPlayer.setCollideWorldBounds(true);
  localPlayer.setBounce(0.1);
  localPlayer.setTint(myColor);
  localPlayer.body.setGravityY(800);

  this.physics.add.collider(localPlayer, platforms);

  players[myId] = {
    sprite: localPlayer,
    x: localPlayer.x,
    y: localPlayer.y,
    color: myColor
  };

  keys = this.input.keyboard.addKeys({
    left: Phaser.Input.Keyboard.KeyCodes.A,
    right: Phaser.Input.Keyboard.KeyCodes.D,
    jump: Phaser.Input.Keyboard.KeyCodes.SPACE,
    up: Phaser.Input.Keyboard.KeyCodes.W
  });

  // Basit anahtar-kapı örneği
  const key = this.add.rectangle(800, 100, 30, 40, 0xffdd00).setOrigin(0.5);
  const door = this.add.rectangle(880, 460, 60, 100, 0x00aaff).setOrigin(0.5);
  this.physics.add.existing(key, true);
  this.physics.add.existing(door, true);

  this.physics.add.overlap(localPlayer, key, () => { key.destroy(); alert("Anahtar alındı!"); });
  this.physics.add.overlap(localPlayer, door, () => { if (!key.active) alert("Seviye tamam!"); });
}

function update() {
  if (!localPlayer) return;

  let vx = 0;
  if (keys.left.isDown) vx = -220;
  if (keys.right.isDown) vx = 220;
  localPlayer.setVelocityX(vx);

  if ((keys.jump.isDown || keys.up.isDown) && localPlayer.body.touching.down) {
    localPlayer.setVelocityY(-450);
    jumpSound.play();
  }

  // Pozisyon güncelle + broadcast
  if (Math.abs(localPlayer.x - players[myId].x) > 4 || Math.abs(localPlayer.y - players[myId].y) > 4) {
    players[myId].x = localPlayer.x;
    players[myId].y = localPlayer.y;

    connections.forEach(conn => {
      if (conn.open) {
        conn.send({
          type: 'move',
          from: myId,
          x: localPlayer.x,
          y: localPlayer.y,
          room: roomId
        });
      }
    });
  }
}

function createRemotePlayer(id, x = 200, y = 200) {
  const scene = game.scene.scenes[0];
  const remote = scene.physics.add.sprite(x, y, 'player');
  remote.setTint(players[myId]?.color || 0xffffff); // basit renk
  remote.setCollideWorldBounds(true);
  remote.body.setAllowGravity(false);

  players[id] = { sprite: remote, x, y };
}
</script>
</body>
</html>
